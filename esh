#!/bin/sh

#             .x+=:.
#             z`    ^%    .uef^"
#                 .   <k :d88E
#     .u       .@8Ned8" `888E
#  ud8888.   .@^%8888"   888E .z8k
# :888'8888. x88:  `)8b.  888E~?888L                (É”) 2025 trvv.me
# d888 '88%" 8888N=*8888  888E  888E
# 8888.+"     %8"    R88  888E  888E                  "yOUR eSHCAPE"
# 8888L        @8Wou 9%   888E  888E
# '8888c. .+ .888888P`    888E  888E
#  "88888%   `   ^"F     m888N= 888>
#      "YP'                 `Y"   888
#                                  J88"
#                                  @%
#                                :"

alias @set='eval "set -f; set +f --"'
alias isnt='! is'

_() {
	push FN "$1"
	"$@"
	eval "pop FN; return $?"
}

all() {
	eval "
		shift
		while test $# -gt 0; do
		    $1 \"\$1\" && shift || return
		done
    "
}

are() {
    test $# = 0 || throw "are: expected predicate" || return
    is name "$1" || throw "is: $1: bad name" || return
	eval "shift; all 'is $1' \"\$@\""
}

is() {
    case $# in
        (2) :;;
        (0) throw "is: expected predicate and argument";;
        (1) throw "is: expected argument";;
        (*) throw "is: too many arguments";;
    esac || return
	# TODO: These need to be made sexier. I have no idea quite how to do it, though.
    case $1 in
        (name)          ! match '[!A-Za-z_]*|*[!A-Za-z_0-9]*' "$2";;
        (natural)       ! match '*[!0-9]*' "$2";;
		(command)       >/dev/null command -V "$2";;
        (block)         test -b "$2";;
        (stream)        test -c "$2";;
        (directory)     test -d "$2";;
        (empty)         test -s "$2";;
        (extant)        test -e "$2";;
        (file)          test -f "$2";;
        (sgid)          test -g "$2";;
        (symlink)       test -h "$2";;
        (fifo)          test -p "$2";;
        (readable)      test -r "$2";;
        (socket)        test -S "$2";;
        (terminal)      test -t "$2";;
        (suid)          test -u "$2";;
        (writeable)     test -w "$2";;
        (executable)    test -x "$2";;
        (null)          test -z "$2";;
		(*)             throw "is: $2: bad predicate";;
    esac
}

throw() {
    eval "
        >&2 printf '%s\\n' \"\$@\"
        case \$- in
            (*i*) return $(($? ? $? : 254));;
            (*) exit $(($? ? $? : 255));;
        esac
    "
}

wrap() {
    test $# = 0 && return
	while test $# != 1; do
		quote "$1" ' '
		shift
	done
	quote "$1"
}

match() {
    case $# in
        (2) :;;
        (0) throw "match: expected pattern";;
        (1) throw "match: expected expression";;
        (*) throw "match: too many arguments"
    esac || return
    eval "case \$2 in ($1) :;; (*) return 1;; esac"
}

quote() {
    case $# in
        (1|2) :;;
        (0) throw "quote: expected string";;
        (*) throw "quote: too many arguments";;
    esac || return
    if 2>/dev/null match '*'"'"'*' "$1"; then
        # shellcheck disable=SC2139
        set -- "$(alias _="$1"; alias _)" ${2+"$2"}
        printf '%s%b' "${1#??}" "${2-\\n}"
    else
        printf '%s%b' "'$1'" "${2-\\n}"
    fi
}

# Safely expand variable by name.
peek() {
    case $# in
        (1) :;;
        (0) throw "peek: expected name";;
        (*) throw "peek: too many arguments";;
    esac || return
    is name "$1" || throw "peek: $1: bad name" || return
    eval "printf '%s\\n' \"\$$1\""
}

expand() {
    case $# in
        (1) :;;
        (0) throw "expand: expected expansion";;
        (*) throw "expand: too many arguments";;
    esac || return
    eval "printf '%s\\n' \"\${$1}\""
}

put() {
	test $# != 0 || throw "put: expected name or definition" || return
    while test $# != 0; do
		# NOTE: Might be a way to make this a single check on the string.
        is name "${1%%=*}" || throw "put: $1: bad name" || return
		if match '*=*' "$1"; then
			eval "${1%%=*}=\${1#*=}"
		else
			unset -v "$1"
		fi
        shift
    done
}

# This is actually a terrible implementation of push. All of the items in the
# stack should be stored as their own variables for reasonable indexing.
#
# The basic idea is that for a variable $X that is described as a stack should
# have a corresponding stack pointer at $X_ which will contain a natural number
# of the highest current stack position.
#
# ex: push X="a" X="b"
# 
# This example should result in $X = "b", $X_ = "2", and $X_1 = "a".
#
# A pop[s] operation on X should result in $X = "a", $X_ = "1", and $X_1 is unset.

push() {
    test $# != 0 || throw "push: expected name or definition" || return
    while test $# != 0; do
        is name "${1%%=*}" || throw "push: $1: bad name" || return
        eval "
            : \${${1%%=*}_=1}
            if defined ${1%%=*}; then
                eval \"put ${1%%=*}_\\\${${1%%=*}_\${${1%%=*}_}}=\\\${1#*=}\"
            else
                eval \"unset -v ${1%%=*}_\\\${${1%%=*}_\${${1%%=*}_}}\"
            fi
            ${1%%=*}_=\$((${1%%=*}_ + 1))
        "
        put "$1"
        shift
    done
}

oldpush() {
    case $# in
        (0) THIS=push throw "expected name or definition";;
        (*)
            while test $# != 0; do
                case ${1%%=*} in
                    ([!A-Za-z_]*|*[!A-Za-z_0-9]*) THIS=push throw "$1: bad name";;
                    (*)
                        # Lord have mercy. I wonder if the subshell can be destroyed.
                        eval "
                            case \${${1%%=*}+.} in
                                (.) __${1%%=*}=\"\$(wrap \"\$${1%%=*}\")\${__${1%%=*}+ \${__${1%%=*}}}\";;
                                ('') :;;
                            esac
                        "
                        case $1 in
                            (*=*) eval "${1%%=*}=\${1#*=}";;
                            (*) unset "$1";;
                        esac
                    ;;
                esac
                shift
            done
        ;;
    esac
}

# Congeal a variable and its shadow stack into one quote list.
xlist() {
    case $# in
        (0) THIS=list throw "expected name";;
        (1)
            case $1 in
                ([!A-Za-z_]*|*[!A-Za-z_0-9]*) THIS=list throw "$1: bad name";;
                (*)
                    eval "
                        case \"\${$1+1}\${__$1+2}\" in
                            (1*)
                                printf '%s\\n' \"\$(wrap \"\$$1\")\${__$1+ \${__$1}}\"
                            ;;
                            (2)
                                # TODO: Figure out how to deal with 'null' nodes
                            ;;
                            (*)
                                THIS=list throw \"\$1: undefined list\"
                            ;;
                        esac
                    "
                ;;
            esac
        ;;
        (*) THIS=list throw "too many arguments";;
    esac
}

unlist() {
    test $# != 0 || throw "expected name(s)" || return
    while test $# != 0; do
        is name "$1" || throw "unlist: $1: bad name" || return
        eval "unset $1 __$1"
        shift
    done
}

pop() {
    case $# in
        (0) THIS=pop throw "expected name";;
        (1)
            case $1 in
                ([!A-Za-z_]*|*[!A-Za-z_0-9]*) THIS=pop throw "$1: bad name";;
                (*)
                    # the subshells here should be removeable with a nested
                    # eval, except for the quote
                    eval "
                        case \$- in
                            (*f*) set -- $(peek "__$1");;
                            (*) set -f; set +f -- $(peek "__$1");;
                        esac
                        $1=\$1
                        2>/dev/null shift || unset $1 __$1
                        __$1=\"\$(quote \"\$@\")\"
                    "
                ;;
            esac
        ;;
        (*) THIS=pop throw "too many arguments";;
    esac
}

defined() {
    while test $# -gt 0; do
        eval "case \${$1+.} in ('') return 1;; esac"
        shift
    done
}

# Mask a shell option for the parameterized command. If no arguments are
# provided it will determine if the option is set. Unsafe (for now).
setmask() {
    case $# in
        (0) THIS=setmask throw "expected option character";;
        (1)
            case $1 in
                ([A-Za-z0-9]) eval "case \$- in (*$1*) :;; (*) return 1;; esac";;
                (*[!A-Za-z0-9_]*) THIS=setmask throw "$1: invalid option";;
                (*)
                    # TODO: Support checking for if the option exists at all or not
                    set -- "$1" "$(set +o)"
                    case $2 in
                        (*"-o $1"*) return 0;;
                        (*"+o $1"*) return 1;;
                        (*) THIS=setmask STATUS=2 throw "$1: option not found";;
                    esac
                    #eval "set +o | grep \"-o $1\" 2>/dev/null"
                ;;
            esac
        ;;
        (*)
            case $1 in
                ([A-Za-z0-9])
                    eval "
                        shift
                        case \$- in
                            (*$1*) \"\$@\";;
                            (*)
                                if set -$1; then
                                    \"\$@\"
                                    eval \"
                                        set +$1
                                        return \$?
                                    \"
                                else
                                    THIS=\"\${THIS-setmask}\" throw \"$1: failed to set option\"
                                fi
                            ;;
                        esac
                    "
                ;;
                (*[!A-Za-z0-9_]*) THIS=setmask throw "$1: invalid option";;
                (*)
                    # This depends on the User Portability Utilities being present,
                    # which I feel pretty comfortable in assuming for most platforms.
                    # Maybe add a check if anyone runs into any situations where this
                    # is actually a problem.
                    eval "
                        shift
                        # Get rid of this grep
                        if set +o | grep \"-o $1\" 2>/dev/null >&2; then
                            \"\$@\"
                        else
                            if set -o $1; then
                                \"\$@\"
                                eval \"
                                    set +o $1
                                    return \$?
                                \"
                            else
                                THIS=\"\${THIS-setmask}\" throw \"$1: failed to set option\"
                            fi
                        fi
                    "
                ;;
            esac
        ;;
    esac
}

# Report status (without modifying it) or set it.
status() {
    case $# in
        (0) printf '%s\n' "$?";;
        (1)
            case $1 in
                (pass) return 0;;
                (fail) return 1;;
                (*[!0-9]*) THIS=status throw "bad value, expected integer";;
                (*) return "$1";;
            esac
        ;;
        (*) THIS=status throw "too many arguments";;
    esac
}

# Stick variable value into the back of the history of a given vartiable.
queue() {
    case $# in
        (0) THIS=queue throw "expected name or definition";;
        (*)
            while test $# != 0; do
                case ${1%%=*} in
                    ([!A-Za-z_]*|*[!A-Za-z_0-9]*) THIS=queue throw "$1: bad name";;
                    (*)
                        eval "__${1%%=*}=\"\${__${1%%=*}+\${__${1%%=*}} }\$(quote \"\${1#*=}\")\""
                    ;;
                esac
                shift
            done
        ;;
    esac
}

# TODO: Feature, bug detection
