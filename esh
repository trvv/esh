#!/bin/sh
# ```
#             .x+=:.
#             z`    ^%    .uef^"
#                 .   <k :d88E
#     .u       .@8Ned8" `888E
#  ud8888.   .@^%8888"   888E .z8k
# :888'8888. x88:  `)8b.  888E~?888L                (É”) 2025 trvv.me
# d888 '88%" 8888N=*8888  888E  888E
# 8888.+"     %8"    R88  888E  888E                  "yOUR eSHCAPE"
# 8888L        @8Wou 9%   888E  888E
# '8888c. .+ .888888P`    888E  888E
#  "88888%   `   ^"F     m888N= 888>
#      "YP'                 `Y"   888
#                                  J88"
#                                  @%
#                                :"
# ```

# # Introduction
# 
# *Esh* is a library for writing portable programs on any POSIX compliant Unix
# system entirely within the system shell.

# # Source

out() {
    # Simplified string printing. 
    printf '%s\n' "$@"
}

shmd() {
    #push line state=code
    state=docs
    while IFS= read -r line; do
        case $state in
            (code)
                case $line in
                    ('')
                        # shellcheck disable=SC2016
                        printf '\n';;
                    ('# '*)
                        printf '```\n%s\n' "${line#??}"
                        state=docs
                    ;;
                    (*'() {'*)
                        # shellcheck disable=SC2016
                        printf '```\n## `%s`\n```sh\n%s\n' "${line%%\(\)*}" "$line"
                    ;;
                    (*) printf '%s\n' "$line";;
                esac
            ;;
            (docs)
                case $line in
                    ('') :;;
                    ('#') printf '\n\n';;
                    ('# '*) printf '%s\n' "${line#??}";;
                    (*[A-Za-z_0-9]'() {'*)
                        # shellcheck disable=SC2016
                        printf '## `%s`\n```sh\n%s\n' "${line%%\(\)*}" "$line"
                        state=code
                    ;;
                    (*)
                        printf '```sh\n%s\n' "$line"
                        state=code
                    ;;
                esac
            ;;
        esac
        >&2 echo "$state| $line"
    done
    #pop line state
}

_() {
	push FN "$1"
	"$@"
	eval "pop FN; return $?"
}

all() {
	eval "
		shift
		while test $# -gt 0; do
		    $1 \"\$1\" && shift || return
		done
    "
}

are() {
    test $# = 0 || throw "are: expected predicate" || return
    is name "$1" || throw "is: $1: bad name" || return
	eval "shift; all 'is $1' \"\$@\""
}

is() {
    case $# in
        (2) :;;
        (0) throw "is: expected predicate and argument";;
        (1) throw "is: expected argument";;
        (*) throw "is: too many arguments";;
    esac || return
	# TODO: These need to be made sexier. I have no idea quite how to do it, though.
    case $1 in
        (name)          ! match '[!A-Za-z_]*|*[!A-Za-z_0-9]*' "$2";;
        (natural)       ! match '*[!0-9]*' "$2";;
		(command)       >/dev/null command -V "$2";;
        (block)         test -b "$2";;
        (stream)        test -c "$2";;
        (directory)     test -d "$2";;
        (empty)         test -s "$2";;
        (extant)        test -e "$2";;
        (file)          test -f "$2";;
        (sgid)          test -g "$2";;
        (symlink)       test -h "$2";;
        (fifo)          test -p "$2";;
        (readable)      test -r "$2";;
        (socket)        test -S "$2";;
        (terminal)      test -t "$2";;
        (suid)          test -u "$2";;
        (writeable)     test -w "$2";;
        (executable)    test -x "$2";;
        (null)          test -z "$2";;
		(*)             throw "is: $2: bad predicate";;
    esac
}

throw() {
    eval "
        >&2 printf '%s\\n' \"\$@\"
        case \$- in
            (*i*) return $(($? ? $? : 254));;
            (*) exit $(($? ? $? : 255));;
        esac
    "
}

wrap() {
    test $# = 0 && return
	while test $# != 1; do
		quote "$1" ' '
		shift
	done
	quote "$1"
}

match() {
    case $# in
        (2) :;;
        (0) throw "match: expected pattern";;
        (1) throw "match: expected expression";;
        (*) throw "match: too many arguments"
    esac || return
    eval "case \$2 in ($1) :;; (*) return 1;; esac"
}

quote() {
    case $# in
        (1|2) :;;
        (0) throw "quote: expected string";;
        (*) throw "quote: too many arguments";;
    esac || return
    if match '*'"\\'"'*' "$1"; then
        # shellcheck disable=SC2139
        set -- "$(alias _="$1"; alias _)" ${2+"$2"}
        printf '%s%b' "${1#??}" "${2-\\n}"
    else
        printf '%s%b' "'$1'" "${2-\\n}"
    fi
}
# 
# Safely expand variable by name.
peek() {
    case $# in
        (1) :;;
        (0) throw "peek: expected name";;
        (*) throw "peek: too many arguments";;
    esac || return
    is name "$1" || throw "peek: $1: bad name" || return
    xeval "out \"\$$1\""
}

expand() {
    case $# in
        (1) :;;
        (0) throw "expand: expected expansion";;
        (*) throw "expand: too many arguments";;
    esac || return
    eval "printf '%s\\n' \"\${$1}\""
}

put() {
	test $# != 0 || throw "put: expected name or definition" || return
    while test $# != 0; do
		# NOTE: Might be a way to make this a single check on the string.
        is name "${1%%=*}" || throw "put: $1: bad name" || return
		if match '*=*' "$1"; then
			eval "${1%%=*}=\${1#*=}"
		else
			unset -v "$1"
		fi
        shift
    done
}

move() {
    test $# = 2 || throw "move: expected target and source" || return
    is name "$1" || throw "move: $1: bad name (target)" || return
    is name "$2" || throw "move: $2: bad name (source)" || return
    move_unsafe "$1" "$2"
}

move_unsafe() {
    eval "$1=\$$2"
}

# TODO: Implement a pull operator that works like a pop from the 

push() {
    test $# != 0 || throw "push: expected name or definition" || return
    while test $# != 0; do
        is name "${1%%=*}" || throw "push: $1: bad name" || return
        eval "
            if defined ${1%%=*}; then
                __move ${1%%=*}_\${${1%%=*}_=1} \$${1%%=*}
            else
                unset -v ${1%%=*}_\${${1%%=*}_=1}
            fi
            ${1%%=*}_=\$((${1%%=*}_ + 1))
        "
        put "$1"
        shift
    done
}

pop() {
    test $# != 0 || throw "pop: expected name(s)" || return
    while test $# != 0; do
        is name "$1" || throw "pop: $1: bad name" || return
        eval "
            if defined ${1}_; then
                out \$$1
                if __defined ${1}_\$((\${${1}_} - 1)); then
                    __move $1 ${1}_\$((\${${1}_} - 1))
                    # this unset is not necessary, but we might want it for cleanliness sake
                    #unset -v ${1}_\$((\${${1}_} - 1))
                else
                    unset -v $1
                fi
            else
                throw 'pop: nothing to pop'
                return 1
            fi
            ${1}_=\$((${1}_ - 1))
        "
        shift
    done
}

pops() {
    :
}

# Congeal a variable and its shadow stack into one quote list.
xlist() {
    case $# in
        (0) THIS=list throw "expected name";;
        (1)
            case $1 in
                ([!A-Za-z_]*|*[!A-Za-z_0-9]*) THIS=list throw "$1: bad name";;
                (*)
                    eval "
                        case \"\${$1+1}\${__$1+2}\" in
                            (1*)
                                printf '%s\\n' \"\$(wrap \"\$$1\")\${__$1+ \${__$1}}\"
                            ;;
                            (2)
                                # TODO: Figure out how to deal with 'null' nodes
                            ;;
                            (*)
                                THIS=list throw \"\$1: undefined list\"
                            ;;
                        esac
                    "
                ;;
            esac
        ;;
        (*) THIS=list throw "too many arguments";;
    esac
}

defined() {
    is name "$1" || throw "defined: $1: bad name" || return
    __defined "$@"
}

__defined() {
    eval "case \${$1+.} in ('') return 1;; esac"
}

# Mask a shell option for the parameterized command. If no arguments are
# provided it will determine if the option is set. Unsafe (for now).
setmask() {
    case $# in
        (0) THIS=setmask throw "expected option character";;
        (1)
            case $1 in
                ([A-Za-z0-9]) eval "case \$- in (*$1*) :;; (*) return 1;; esac";;
                (*[!A-Za-z0-9_]*) THIS=setmask throw "$1: invalid option";;
                (*)
                    # TODO: Support checking for if the option exists at all or not
                    set -- "$1" "$(set +o)"
                    case $2 in
                        (*"-o $1"*) return 0;;
                        (*"+o $1"*) return 1;;
                        (*) THIS=setmask STATUS=2 throw "$1: option not found";;
                    esac
                    #eval "set +o | grep \"-o $1\" 2>/dev/null"
                ;;
            esac
        ;;
        (*)
            case $1 in
                ([A-Za-z0-9])
                    eval "
                        shift
                        case \$- in
                            (*$1*) \"\$@\";;
                            (*)
                                if set -$1; then
                                    \"\$@\"
                                    eval \"
                                        set +$1
                                        return \$?
                                    \"
                                else
                                    THIS=\"\${THIS-setmask}\" throw \"$1: failed to set option\"
                                fi
                            ;;
                        esac
                    "
                ;;
                (*[!A-Za-z0-9_]*) THIS=setmask throw "$1: invalid option";;
                (*)
                    # This depends on the User Portability Utilities being present,
                    # which I feel pretty comfortable in assuming for most platforms.
                    # Maybe add a check if anyone runs into any situations where this
                    # is actually a problem.
                    eval "
                        shift
                        # Get rid of this grep
                        if set +o | grep \"-o $1\" 2>/dev/null >&2; then
                            \"\$@\"
                        else
                            if set -o $1; then
                                \"\$@\"
                                eval \"
                                    set +o $1
                                    return \$?
                                \"
                            else
                                THIS=\"\${THIS-setmask}\" throw \"$1: failed to set option\"
                            fi
                        fi
                    "
                ;;
            esac
        ;;
    esac
}

# Report status (without modifying it) or set it.
status() {
    case $# in
        (0) printf '%s\n' "$?";;
        (1)
            case $1 in
                (pass) return 0;;
                (fail) return 1;;
                (*[!0-9]*) THIS=status throw "bad value, expected integer";;
                (*) return "$1";;
            esac
        ;;
        (*) THIS=status throw "too many arguments";;
    esac
}

# Stick variable value into the back of the history of a given vartiable.
queue() {
    case $# in
        (0) THIS=queue throw "expected name or definition";;
        (*)
            while test $# != 0; do
                case ${1%%=*} in
                    ([!A-Za-z_]*|*[!A-Za-z_0-9]*) THIS=queue throw "$1: bad name";;
                    (*)
                        eval "__${1%%=*}=\"\${__${1%%=*}+\${__${1%%=*}} }\$(quote \"\${1#*=}\")\""
                    ;;
                esac
                shift
            done
        ;;
    esac
}

# TODO: Feature, bug detection
